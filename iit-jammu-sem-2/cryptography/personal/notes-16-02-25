:: Computation Security ::

PT : An algorithm A is polynomial-time if there is a polynomial P(.) s.t. 
for all large enough n = |x|, running time of A(x) is bounded by P(|x|)

NOTE : running time


PPT : An algorithm is probablistic polynomial-time if there is a polynomial
P(.) s.t. for all large enough n = |x|, expected running time of A(x) is 
bounded by P(|x|)

NOTE : expected running time

why two definitions? 
-- think about tossing the coin.

Negligible/Noticeable Function

v(n) - is negligible if for all polynomial P(n), for all large enough n, 
v(n) < 1/P(n)

Noticeable Function 
lambda(n) - is noticeable if there exists P(n), Q(n) s.t. for all large enough n
      1/P(n) <= lambda(n) <= Q(n)

> negl(n) . notice(n) = negl(n)
> negl(n) + notice(n) = notice(n)

Noticeable time negligible or Negligible time Noticeable both will be negligible,
isn't it simple to see?

**************  PR(B)G Indistinguishability ************

Informal : No "polynomial-time adversary" should be able to distinguish the keystream
           generated by a PR(B)G from a truly random sequence.
Formal   : For p(k) > k, G {0,1}^k ----> {0,1}^p(k) is indistinguishable,
            if for all PPT algorithm D,

            |Pr[D(G(x))=1 : x <- {0,1}^k] - Pr[D(R) = 1: R <- {0,1}^p(k)]|

Explaining formal - Take an x from a distribution of {0,1}^k.
                    Use a generator G to generate a Key stream using x
                    i.e. gp(k)

                    Take a truly random string from same distribution R

                    On applying any PPT algorithm on both of them,
                    it won't be able to distinguish between them and 
                    return 
                        Pr[D(G(x)) = 1 : x < {0,1}^k] <
                           Pr[D(R) = 1: R <- {0,1}^p(k)] + negl(k)
                    

**************  PR(B)G UNPREDICTABILITY ************

Informal : Given output-stream of length l , no "poly-time adversary" should
            be able to gain any information about the rest of the stream.

Formal : For p(k) > k, G: {0,1}^k ---> {0,1}^p(k) is unpredictable, if 
         for all PPT algorithm P , for all i belongs to [p(k)]

    Pr[gi = b] : x <--- {0, 1}^k, (g1, ... gp(k)) <- G(x), b <- P(g1, .. gi-1)]
                              < 1/2 + negl(k)

        given : 
            x : take a string from {0,1}^k 
            g1, g2, ... gp(k) : Generate key-stream using G(x) 
            b :  next gi guessed using g1 ... gi-1 

            the probability of classifying gi ==? b should be < 1/2 + neg
            for the unpredictability.

*******  Indistinguishability vs Unpredictability ********

L2R. G achieves Indistinguishability => G achieves Unpredictability

Proof : 
    We prove the contrapositive i.e. If G does not achieve Unpredictability
    then the output of G is distinguishable from a random (binary) string
    of length p(k)

Proof : 
> Let a PPT P breaks unpredictability for some i belongs to [p[k]]
> We define distinguisher D as following : 

> def D(y1...yp(k)):
  Let g <--- P(y1...yi-1)
  If g = yi, o/p 1
  else: o/p 0

> If y = G(x) for x <-- {0, 1} ^ k,
      Pr[D(y)] = 1 = Pr[there exists i : P(y1,... yi-1) = yi] >= 1/2 + v(k)

> If R <--- {0,1}^ p(k),
      Pr[D(y)=1] = Pr[for all i: P(y1...yi-1)=yi] = 1/2

> Then, |Pr[D(G(x))] = 1: x <-- {0,1}^k] 
                - Pr[D(R) = 1: R <- {0,1}^p(k)|   >= v(k)
> Thus D wins with noticeable probability

Indistinguishability vs Unpredictability (contd.)

R2L. G achieves Unpredictability => G achieves indistinguishability

Proof : Not so simple


:: Computational Indistinguishability ::

Def. X0 and X1 are computationally indistinguishable if for all PPT A

  |Pr[A(x)=1 :x <--- X0] - Pr[A(x) = 1 : x <-- X1| < negl(k)

  > We write X0 ~~c X1
  > Diff is also called distinguishing advantage of A w.r.t. X0 and X1

Properties : 

P1. Let X0 ~~c X1 . Then for all PPT M,
    M(X0) ~~c M(X1) i.e.

    M(x belongs to {0,1}^p(k) : x <--- X0) ~~c
                              M(x belongs to {0,1}^p(k) : x <-- X1)

P2. X ~~c Y and Y ~~c Z => X ~~c Z

Proof P1 : Try proving contrapositive i.e.
    1. Let there exists PPT D that separate M(X0) and M(X1)
    2. Define another PPT D'(z) that runs D(M(z))
    3. Adv_D'[X0, X1] (k) = Adv_D[M(X0), M(X1)](k)

Proof P2 :
  X ~~c Y and Y ~~c Z => X ~~c Z

  v(xz) = |Pr[A(x) = 1 : x <-- X] - Pr[A(x)=1 : x <- Z]|
        = |Pr[A(x) = 1 : x <-- X] - Pr[A(x) = 1 : x <- Y]
            +Pr[A(x) = 1 : x <- Y] - Pr[A(x)=1 : x <- Z]|
        = v(xy) + v(yz)
  If v(xy) and v(yz) are negl, v(xz) is negl.

          : Hybrid Lemma : 
Def : Let n = P(k) is fixed for some polynomial P(.)
      If X0 ~~c X1, X1 ~~c X2, ... , Xn-1 ~~c Xn then X0 ~~c Xn

Proof : 
> If D distinguishes X0 and Xn with noticeable advantage, we use it to 
  distinguish Xi and Xi-1 with noticeable advantage for some i.

To Prove: 
        If Adv_D [X0, Xn] >= lambda, then for some i belongs to [n],
            Adv_D [Xi, Xi+1] 